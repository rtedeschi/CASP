(s0, () -> s1
(s0, )) -> s2
(s0, [) -> s11
(s0, ]) -> s12
(s0, *) -> s19
(s0, %) -> s15
(s0, -) -> s9
(s0, +) -> s7
(s0, =) -> s16
(s0, &) -> s5
(s0, |) -> s4
(s0, ,) -> s3
(s0, .) -> s13
(s0, ;) -> s6
(s0, /) -> s20
(s0, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_) -> s14
(s0, 1234567890) -> s17
(s7, +) -> s8
(s9, -) -> s10
(s14, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_) -> s14
(s17, .) -> s18
(s17, 1234567890) -> s17
(s18, 1234567890) -> s18

I(s0)
F(s1, L_PAREN)
F(s2, R_PAREN)
F(s3, COMMA)
F(s4, BITOR)
F(s5, BITAND)
F(s6, SEMICOLON)
F(s7, PLUS)
F(s8, INCR)
F(s9, MINUS)
F(s10, DECR)
F(s11, L_SQ_BRACKET)
F(s12, R_SQ_BRACKET)
F(s13, PERIOD)
F(s14, ID)
F(s15, MOD)
F(s16, ASSIGN)
F(s17, INT_LITERAL)
F(s18, FLOAT_LITERAL)
F(s19, ASTERISK)
F(s20, SLASH)

T(L_PAREN, "(")
T(R_PAREN, ")")
T(L_SQ_BRACKET, "[")
T(L_SQ_BRACKET, "]")
T(ASTERISK, "*")
T(MOD, "%")
T(MINUS, "-")
T(DECR, "--")
T(PLUS, "+")
T(INCR, "++")
T(ASSIGN, "=")
T(BITAND, "&")
T(BITOR, "|")
T(COMMA, ",")
T(PERIOD, ".")
T(SEMICOLON, ";")
T(SLASH, "/")

ReservedWord(BEGIN, L_CU_BRACKET)
ReservedWord(END, R_CU_BRACKET)
ReservedWord(EQUALS, EQ)
ReservedWord(GRT, GT)
ReservedWord(GRTEQ, GT_EQ)
ReservedWord(LST, LT)
ReservedWord(LSTEQ, LT_EQ)
ReservedWord(NOT, NOT)
ReservedWord(NOTEQ, NOT_EQ)
ReservedWord(AND, AND)
ReservedWord(OR, OR)

ReservedWord(int, INT)
ReservedWord(integer, INTEGER)
ReservedWord(long, LONG)
ReservedWord(short, SHORT)
ReservedWord(byte, BYTE)
ReservedWord(float, FLOAT)
ReservedWord(double, DOUBLE)
ReservedWord(real, REAL)
ReservedWord(precision, PRECISION)
ReservedWord(fixed, FIXED)
ReservedWord(char, CHAR)
ReservedWord(character, CHARACTER)
ReservedWord(bool, BOOL)
ReservedWord(boolean, BOOLEAN)
ReservedWord(void, VOID)
ReservedWord(true, TRUE)
ReservedWord(false, FALSE)
ReservedWord(for, FOR)
ReservedWord(while, WHILE)
ReservedWord(do, DO)
ReservedWord(if, IF)
ReservedWord(else, ELSE)
ReservedWord(return, RETURN)

function-definition =:
<function-return-type> <function-identifier> <function-parameters> <function-body>

statement-list =:
<statement>+

statement =:
(<expression> [SEMICOLON])|<for-loop>|<decision>|<block>

for-loop =:
[FOR] [L_PAREN] <for-init> [SEMICOLON] <for-condition> [SEMICOLON] <for-increment> [R_PAREN] <for-body>

decision =:
[IF] [L_PAREN] <expression> [R_PAREN] (<block>|<statement>|[SEMICOLON]) <decision-case>* <decision-fallback>?

decision-case =:
[ELSE] [IF] [L_PAREN] <expression> [R_PAREN] (<block>|<statement>|[SEMICOLON]) 

decision-fallback =:
[ELSE] (<block>|<statement>|[SEMICOLON])

block =:
[L_CU_BRACKET] <statement-list>? [R_CU_BRACKET]

method-invokation =:
<function-identifier> [L_PAREN] <arg-list>? [R_PAREN]

declaration-list =:
<declaration> ([COMMA] <declaration>)*

arg-list =:
<expression> ([COMMA] <expression>)*

expression =:
([L_PAREN] <expression> [R_PAREN])|<method-invokation>|<declaration>|<assignment>|<binary-expression>|<unary-expression>|<literal>|<return>|<identifier>

declaration =:
<type> [ID] ([ASSIGN] <expression>)?

assignment =:
[ID] [ASSIGN] <expression>

binary-expression =:
<relational-expression>|<algebraic-expression>|<logical-expression>

relational-expression =:
<literal>|[ID] (<relational-binary-op> <expression>)+

algebraic-expression =:
<literal>|[ID] (<math-binary-op> <expression>)+

logical-expression =:
<literal>|[ID] (<logical-binary-op> <expression>)+


unary-expression =:
([NOT] [ID])|([ID] <unary-op>)|(<unary-op> [ID])

literal =:
<bool-literal>|[FLOAT_LITERAL]|[INT_LITERAL]

type =:
<primitive-type>|[ID] [ASTERISK]*

primitive-type =:
<int-primitive>|<float-primitive>|<fixed-primitive>|<char-primitive>|<bool-primitive>|<void>

binary-op =:
<math-binary-op>|<logical-binary-op>|<relational-binary-op>

return =:
[RETURN] <expression>?


void =:
[VOID]

int-primitive =:
[INT]|[LONG]|[SHORT]|[BYTE]|[INTEGER]

float-primitive =:
[FLOAT]|[DOUBLE]|[REAL]|([DOUBLE] [PRECISION])

fixed-primitive =:
[FIXED]

char-primitive =:
[CHAR]|[CHARACTER]

bool-primitive =:
[BOOL]|[BOOLEAN]

bool-literal =:
[TRUE]|[FALSE]

math-binary-op =:
[PLUS]|[MINUS]|[ASTERISK]|[SLASH]

logical-binary-op =:
[BITAND]|[AND]|[BITOR]|[OR]

relational-binary-op =:
[EQ]|[LT]|[LT_EQ]|[GT]|[GT_EQ]|[NOT_EQ]

unary-op =:
[INCR]|[DECR]


function-return-type =:
<type>

function-identifier =:
[ID]

function-parameters =:
[L_PAREN] <declaration-list>? [R_PAREN]

function-body =:
<block>


for-init =:
<expression>?

for-condition =:
<expression>?

for-increment =:
<expression>?

for-body =:
<block>|<statement>|[SEMICOLON]

identifier =:
[ID]

