(s0, {) -> s1
(s0, }) -> s2
(s0, () -> s3
(s0, )) -> s4
(s0, [) -> s5
(s0, ]) -> s6
(s0, *) -> s7
(s0, %) -> s8
(s0, -) -> s9
(s0, +) -> s11
(s0, =) -> s13
(s0, <) -> s15
(s0, >) -> s17
(s0, !) -> s19
(s0, &) -> s21
(s0, |) -> s23
(s0, ,) -> s25
(s0, .) -> s26
(s0, ;) -> s31
(s0, /) -> s32
(s0, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_) -> s28
(s0, 0123456789) -> s30
(s9, -) -> s10
(s9, .) -> s27
(s9, 0123456789) -> s30
(s11, +) -> s12
(s11, .) -> s27
(s11, 0123456789) -> s30
(s13, =) -> s14
(s15, =) -> s16
(s17, =) -> s18
(s19, =) -> s20
(s21, &) -> s22
(s23, |) -> s24
(s26, 0123456789) -> s27
(s27, 0123456789) -> s27
(s28, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_) -> s28
(s28, 0123456789) -> s29
(s29, abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_) -> s28
(s29, 0123456789) -> s29
(s30, .) -> s27
(s30, 0123456789) -> s30

I(s0)
F(s1, L_CU_BRACKET)
F(s2, R_CU_BRACKET)
F(s3, L_PAREN)
F(s4, R_PAREN)
F(s5, L_SQ_BRACKET)
F(s6, R_SQ_BRACKET)
F(s7, ASTERISK)
F(s8, MOD)
F(s9, MINUS)
F(s10, DECR)
F(s11, PLUS)
F(s12, INCR)
F(s13, ASSIGN)
F(s14, EQ)
F(s15, LT)
F(s16, LT_EQ)
F(s17, GT)
F(s18, GT_EQ)
F(s19, NOT)
F(s20, NOT_EQ)
F(s21, BITAND)
F(s22, AND)
F(s23, BITOR)
F(s24, OR)
F(s25, COMMA)
F(s26, PERIOD)
F(s27, FLOAT_LITERAL)
F(s28, ID)
F(s29, ID)
F(s30, INT_LITERAL)
F(s31, SEMICOLON)
F(s32, SLASH)

T(L_CU_BRACKET, "{")
T(R_CU_BRACKET, "}")
T(L_PAREN, "(")
T(R_PAREN, ")")
T(L_SQ_BRACKET, "[")
T(L_SQ_BRACKET, "]")
T(ASTERISK, "*")
T(MOD, "%")
T(MINUS, "-")
T(DECR, "--")
T(PLUS, "+")
T(INCR, "++")
T(ASSIGN, "=")
T(EQ, "==")
T(LT, "<")
T(LT_EQ, "<=")
T(GT, ">")
T(GT_EQ, ">=")
T(NOT, "!")
T(NOT_EQ, "!=")
T(BITAND, "&")
T(AND, "&&")
T(BITOR, "|")
T(OR, "||")
T(COMMA, ",")
T(PERIOD, ".")
T(SEMICOLON, ";")
T(SLASH, "/")

ReservedWord(int, INT)
ReservedWord(integer, INTEGER)
ReservedWord(long, LONG)
ReservedWord(short, SHORT)
ReservedWord(byte, BYTE)
ReservedWord(float, FLOAT)
ReservedWord(double, DOUBLE)
ReservedWord(real, REAL)
ReservedWord(precision, PRECISION)
ReservedWord(fixed, FIXED)
ReservedWord(char, CHAR)
ReservedWord(character, CHARACTER)
ReservedWord(bool, BOOL)
ReservedWord(boolean, BOOLEAN)
ReservedWord(void, VOID)
ReservedWord(true, TRUE)
ReservedWord(false, FALSE)
ReservedWord(for, FOR)
ReservedWord(while, WHILE)
ReservedWord(do, DO)
ReservedWord(if, IF)
ReservedWord(else, ELSE)
ReservedWord(return, RETURN)

function-definition =:
<function-return-type> <function-identifier> <function-parameters> <function-body>

statement-list =:
<statement>+

statement =:
(<expression> [SEMICOLON])|<for-loop>|<decision>|<block>

for-loop =:
[FOR] [L_PAREN] <for-init> [SEMICOLON] <for-condition> [SEMICOLON] <for-increment> [R_PAREN] <for-body>

decision =:
[IF] [L_PAREN] <expression> [R_PAREN] (<block>|<statement>|[SEMICOLON]) <decision-case>* <decision-fallback>?

decision-case =:
[ELSE] [IF] [L_PAREN] <expression> [R_PAREN] (<block>|<statement>|[SEMICOLON]) 

decision-fallback =:
[ELSE] (<block>|<statement>|[SEMICOLON])

block =:
[L_CU_BRACKET] <statement-list>? [R_CU_BRACKET]

method-invokation =:
<function-identifier> [L_PAREN] <arg-list>? [R_PAREN]

declaration-list =:
<declaration> ([COMMA] <declaration>)*

arg-list =:
<expression> ([COMMA] <expression>)*

expression =:
([L_PAREN] <expression> [R_PAREN])|<method-invokation>|<declaration>|<assignment>|<binary-expression>|<unary-expression>|<literal>|<return>|<identifier>

declaration =:
<type> [ID] ([ASSIGN] <expression>)?

assignment =:
[ID] [ASSIGN] <expression>

binary-expression =:
<relational-expression>|<algebraic-expression>|<logical-expression>

relational-expression =:
<literal>|[ID] (<relational-binary-op> <expression>)+

algebraic-expression =:
<literal>|[ID] (<math-binary-op> <expression>)+

logical-expression =:
<literal>|[ID] (<logical-binary-op> <expression>)+


unary-expression =:
([NOT] [ID])|([ID] <unary-op>)|(<unary-op> [ID])

literal =:
<bool-literal>|[FLOAT_LITERAL]|[INT_LITERAL]

type =:
<primitive-type>|[ID] [ASTERISK]*

primitive-type =:
<int-primitive>|<float-primitive>|<fixed-primitive>|<char-primitive>|<bool-primitive>|<void>

binary-op =:
<math-binary-op>|<logical-binary-op>|<relational-binary-op>

return =:
[RETURN] <expression>?


void =:
[VOID]

int-primitive =:
[INT]|[LONG]|[SHORT]|[BYTE]|[INTEGER]

float-primitive =:
[FLOAT]|[DOUBLE]|[REAL]|([DOUBLE] [PRECISION])

fixed-primitive =:
[FIXED]

char-primitive =:
[CHAR]|[CHARACTER]

bool-primitive =:
[BOOL]|[BOOLEAN]

bool-literal =:
[TRUE]|[FALSE]

math-binary-op =:
[PLUS]|[MINUS]|[ASTERISK]|[SLASH]

logical-binary-op =:
[BITAND]|[AND]|[BITOR]|[OR]

relational-binary-op =:
[EQ]|[LT]|[LT_EQ]|[GT]|[GT_EQ]|[NOT_EQ]

unary-op =:
[INCR]|[DECR]


function-return-type =:
<type>

function-identifier =:
[ID]

function-parameters =:
[L_PAREN] <declaration-list>? [R_PAREN]

function-body =:
<block>


for-init =:
<expression>?

for-condition =:
<expression>?

for-increment =:
<expression>?

for-body =:
<block>|<statement>|[SEMICOLON]

identifier =:
[ID]

